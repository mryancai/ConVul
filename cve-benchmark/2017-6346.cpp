#include <sys/types.h>
#include <pthread.h>
#include <malloc.h>
#include <string.h>
#include <stdio.h>
#include <unistd.h>
#include <atomic>
#include <iostream>
#include <time.h>

#define MUTEX_FOR_CORRECT_EXE_SEQUENCE
#ifdef MUTEX_FOR_CORRECT_EXE_SEQUENCE
pthread_mutex_t lock_for_correct_exe;
#endif

// #define TEST_TIME

#define PACKET_FANOUT_ROLLOVER		3
#define PACKET_FANOUT_FLAG_ROLLOVER	0x1000

#define	EINVAL		22
#define	ENOMEM		12
#define ENOSPC		28

#define u8 unsigned char
#define u16 unsigned short

pthread_mutex_t fanout_mutex;

typedef struct {
	std::atomic_int counter;
} atomic_t;

typedef atomic_t atomic_long_t;

struct sock{
    int num;
};

struct packet_rollover {
	int			sock;
	atomic_long_t		num;
};

struct packet_sock {
	struct sock		sk;
	struct packet_rollover	*rollover;
};

struct pthread_args{
    struct sock* sk;
    u16 type_flags;
    int thread_id;
};


static struct packet_sock *pkt_sk(struct sock *sk)
{
	return (struct packet_sock *)sk;
}

static void *kzalloc(unsigned size)
{
    void *p = memalign(8, size);
    if (!p)
        return p;
    memset(p, 0, size);

    return p;
}

static void kfree(void *p)
{
	if (p)
    {
        free(p);
    }

}

void atomic_long_set(atomic_long_t* n, int v){
    n->counter = v;
}

static int fanout_add(struct sock *sk, u16 type_flags, int thread_id)
{
    struct packet_sock *po = pkt_sk(sk);
    u8 type = type_flags & 0xff;
    int err;

    if (type == PACKET_FANOUT_ROLLOVER ||
        (type_flags & PACKET_FANOUT_FLAG_ROLLOVER)) {

        po->rollover = (packet_rollover*)kzalloc(sizeof(*po->rollover));
        if (!po->rollover)
            return -ENOMEM;
        printf("thread %d kzalloc, po->rollover = %p\n", thread_id, po->rollover);

        atomic_long_set(&po->rollover->num, 0);
        printf("thread %d change.\n", thread_id);

    }

    pthread_mutex_lock(&fanout_mutex);
    err = -EINVAL;
    pthread_mutex_unlock(&fanout_mutex);

    if (err) {
        kfree(po->rollover);
        printf("thread %d free.\n", thread_id);

        // po->rollover = NULL;
    }

#ifdef MUTEX_FOR_CORRECT_EXE_SEQUENCE
    if(thread_id == 2)
        pthread_mutex_unlock(&lock_for_correct_exe);
#endif

    return err;
}

void* thread_func(void* args){
    struct sock *sk = ((pthread_args*)args)->sk;
    u16 type_flags = ((pthread_args*)args)->type_flags;
    int id = ((pthread_args*)args)->thread_id;

    if(id == 1)
#ifdef MUTEX_FOR_CORRECT_EXE_SEQUENCE
        pthread_mutex_lock(&lock_for_correct_exe);
#else
        sleep(1);
#endif
    fanout_add(sk, type_flags, id);
}

int main()
{
#ifdef TEST_TIME
    static double run_time_begin;
    static double run_time_end;
    static double run_time_total;
    run_time_begin = clock();
#endif

#ifdef MUTEX_FOR_CORRECT_EXE_SEQUENCE
    pthread_mutex_init(&lock_for_correct_exe, NULL);
    pthread_mutex_lock(&lock_for_correct_exe);
#endif

    struct packet_sock pktsk;
    struct sock sk;
    pktsk.sk = sk;

    pthread_t t1, t2;

    struct pthread_args args_one, args_two;
    args_one.sk = &sk;
    args_one.type_flags = 3;
    args_one.thread_id = 1;

    args_two.sk = &sk;
    args_two.type_flags = 3;
    args_two.thread_id = 2;

    pthread_mutex_init(&fanout_mutex, NULL);

    pthread_create(&t1, NULL, thread_func, &args_one);
    pthread_create(&t2, NULL, thread_func, &args_two);

    pthread_join(t1, NULL);
    pthread_join(t2, NULL);

    pthread_mutex_destroy(&fanout_mutex);
    printf("\nprogram-successful-exit\n");
#ifdef TEST_TIME
    run_time_end = clock();
    run_time_total = run_time_end - run_time_begin;
    printf("test-the-total-time: %.3lf\n", (double)(run_time_total/CLOCKS_PER_SEC)*1000);
#endif
    return 0;
}
